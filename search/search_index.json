{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"","text":"","title":"Isotopes"},{"location":"#getting-the-most-out-of-aws-simpledb","text":"<p>A serverless, typed and super lightweight object store that enables storage, indexing and querying of JSON documents in AWS SimpleDB using SQL queries. Isotopes is just perfect for small to medium-sized datasets, especially for indexing metadata from other AWS services for flexible querying. It can easily be run from within AWS Lambda and reduces the boilerplate that is necessary to interface with SimpleDB to an absolute minimum.</p>","title":"Getting the most out of AWS SimpleDB"},{"location":"#quick-start","text":"<pre><code>npm install isotopes aws-sdk\n</code></pre> <p>In your project:</p> <pre><code>import { Isotope } from \"isotopes\"\n\nconst isotope = new Isotope&lt;T&gt;({\n  domain: \"&lt;domain&gt;\",\n  key: \"&lt;keyof T&gt;\"\n})\n</code></pre> <p>For detailed instructions see the getting started guide and the API reference guide.</p>","title":"Quick start"},{"location":"contributing/","text":"<p>Interested in contributing to this project? Want to report a bug? Before you do, please read the following guidelines.</p>","title":"Contributing"},{"location":"contributing/#submission-context","text":"","title":"Submission context"},{"location":"contributing/#got-a-question-or-problem","text":"<p>For quick questions there's no need to open an issue as you can reach us on gitter.im.</p>","title":"Got a question or problem?"},{"location":"contributing/#found-a-bug","text":"<p>If you found a bug, you can help us by submitting an issue to the issue tracker in our GitHub repository. Even better, you can submit a pull request with a fix. However, before doing so, please read the submission guidelines.</p>","title":"Found a bug?"},{"location":"contributing/#missing-a-feature","text":"<p>You can request a new feature by submitting an issue to our GitHub Repository. If you would like to implement a new feature, please submit an issue with a proposal for your work first, to be sure that it is of use for everyone. Please consider what kind of change it is:</p> <ul> <li> <p>For a major feature, first open an issue and outline your proposal so   that it can be discussed. This will also allow us to better coordinate our   efforts, prevent duplication of work and help you to craft the change so   that it is successfully accepted into the project.</p> </li> <li> <p>Small features and bugs can be crafted and directly submitted as a pull   request (PR). However, there is no guarantee that your feature will make it   into the master, as it's always a matter of opinion whether if benefits the   overall functionality of this project.</p> </li> </ul>","title":"Missing a feature?"},{"location":"contributing/#submission-guidelines","text":"","title":"Submission guidelines"},{"location":"contributing/#submitting-an-issue","text":"<p>Before you submit an issue, please search the issue tracker. Maybe the problem you are encountering is already known and the discussion might inform you of workarounds readily available.</p> <p>We want to address all the issues as soon as possible, but before fixing a bug we first need to reproduce and confirm it. In order to reproduce bugs we will systematically ask you to provide a minimal reproduction scenario using the custom issue template. Please stick to the issue template.</p> <p>Unfortunately we are not able to investigate / fix bugs without a minimal reproduction scenario, so if we don't hear back from you we may close the issue.</p>","title":"Submitting an issue"},{"location":"contributing/#submitting-a-pull-request","text":"<p>Search GitHub for an open or closed PR that relates to your submission. You don't want to duplicate effort. If you do not find a related issue or PR, go ahead.</p> <ol> <li> <p>Fork the project, make your changes in a separate git branch and add    descriptive messages to your commits.</p> </li> <li> <p>Push your branch to GitHub and send a PR to <code>isotopes:master</code>. If we suggest    changes, rebase your branch and push the changes to your GitHub repository,    which will automatically update your PR.</p> </li> </ol> <p>After your PR is merged, you can safely delete your branch and pull the changes from the main (upstream) repository.</p>","title":"Submitting a pull request"},{"location":"format/","text":"","title":"Format"},{"location":"format/#encoding","text":"<p>The encoding can be set when creating the isotope, e.g.:</p> <pre><code>const isotope = new Isotope&lt;T&gt;({\n  format: { encoding: \"text\" },\n  domain: \"&lt;domain&gt;\",\n  key: \"&lt;keyof T&gt;\"\n})\n</code></pre>  <code>options.format.encoding: \"json\"</code>  <p>All values are JSON-encoded, which means that strings are double-quoted, whereas numbers and booleans are written literally:</p> <pre><code>{\n  \"Name\": \"example\",\n  \"Attributes\": [\n    { \"Name\": \"active\", \"Value\": \"true\" },\n    { \"Name\": \"props.image\", \"Value\": \"\\\"busybox\\\"\" },\n    { \"Name\": \"props.cpus\", \"Value\": \"2\" },\n    { \"Name\": \"props.memory\", \"Value\": \"2048\" },\n    { \"Name\": \"tags[]\", \"Value\": \"\\\"TAG_1\\\"\" },\n    { \"Name\": \"tags[]\", \"Value\": \"\\\"TAG_2\\\"\" }\n  ]\n}\n</code></pre> <p>If you don't plan to use the SimpleDB domain from a non-Isotope client, you should always stick with JSON-encoding because it is more safe than text encoding and comes with no limitations.</p>  <code>options.format.encoding: \"text\"</code>  <p>Isotopes provides the ability to use an alternate encoding and store strings as literals so they are written without quotes:</p> <pre><code>{\n  \"Name\": \"example\",\n  \"Attributes\": [\n    { \"Name\": \"active\", \"Value\": \"true\" },\n    { \"Name\": \"props.image\", \"Value\": \"busybox\" },\n    { \"Name\": \"props.cpus\", \"Value\": \"2\" },\n    { \"Name\": \"props.memory\", \"Value\": \"2048\" },\n    { \"Name\": \"tags[]\", \"Value\": \"TAG_1\" },\n    { \"Name\": \"tags[]\", \"Value\": \"TAG_2\" }\n  ]\n}\n</code></pre> <p>When decoding the data, we intercept <code>JSON.parse</code> assuming that we encountered a literal string if it fails to decode. It's a hack and yes, imposes some limitations:</p> <ol> <li> <p>Numbers that are encoded as strings (e.g. house numbers, because they can   exhibit values as <code>2A</code> etc.) are interpreted as numbers when decoded with   <code>JSON.parse</code>. Countermeasure: ensure that numbers are typed as numbers,   or string fields contain at least one non-number character.</p> </li> <li> <p>If strings accidentally contain valid JSON, e.g. <code>{}</code>, the value is   parsed as JSON and the field gets assigned that precise value. This also   breaks type safety. Countermeasure: ensure that your strings are never   valid JSON by prepending some character that makes <code>JSON.parse</code> fail.</p> </li> </ol> <p>As enforcing as those restrictions may seem to be, it is often true that the properties and characteristics of the data are known a-priori and those special cases can be ruled out with great certainty. This also means that querying the data from other parts of your system gets easier as string values don't need to be enclosed into quotes (and don't start thinking about <code>LIKE</code> queries) which is far more user-friendly.</p>","title":"Encoding"},{"location":"format/#flattening","text":"<p>Isotopes enables the storage of nested JSON objects within SimpleDB which itself is a key-value store with the ability to query using SQL expressions. In order to be compatible with SimpleDB, objects need to be flattened to match the key-value nature of SimpleDB.</p>","title":"Flattening"},{"location":"format/#objects","text":"<p>Nested objects are flattened by concatenating the keys with <code>.</code> and associating the value of the nested object's key with the concatenated path, e.g.:</p> <pre><code>{ \"foo\": { \"bar\": \"baz\" } }\n</code></pre> <p>becomes:</p> <pre><code>{ \"Name\": \"foo.bar\", \"Value\": \"baz\" }\n</code></pre>","title":"Objects"},{"location":"format/#arrays","text":"<p>There are two flavors for nested arrays, both with different use cases. Which flavor is used is actually controlled using the <code>options.format.multiple</code> option when creating the isotope:</p>  <code>options.format.multiple = true</code> (default)  <p>Array values are written as separate attributes. This is especially useful for arrays with primitive values (<code>string</code>, <code>number</code> and <code>boolean</code>) to enable indexing and queryability. Field names are suffixed with <code>[]</code> to indicate an array of values. However, note that SimpleDB doesn't guarantee order of attributes, so only use this if the order of the entries inside the array doesn't matter, e.g. for tagging:</p> <pre><code>{ \"tags\": [\"TAG_1\", \"TAG_2\"] }\n</code></pre> <p>becomes:</p> <pre><code>{ \"Name\": \"tags[]\", \"Value\": \"TAG_1\" },\n{ \"Name\": \"tags[]\", \"Value\": \"TAG_2\" }\n</code></pre>  <code>options.format.multiple = false</code>  <p>Arrays are written as a single attribute using <code>\"json\"</code> encoding. While this guarantees the order of array values, it is certainly not possible to query for separate values using SQL expressions as they are encoded in JSON syntax, e.g.:</p> <pre><code>{ \"tags\": [\"TAG_1\", \"TAG_2\"] }\n</code></pre> <p>becomes:</p> <pre><code>{ \"Name\": \"tags\", \"Value\": \"[\\\"TAG_1\\\", \\\"TAG_2\\\"]\" }\n</code></pre>","title":"Arrays"},{"location":"format/#example","text":"<p>Assume we want to persist the type specified in the getting started guide.</p> <p>When persisting an object of this type with <code>multiple = true</code> and <code>\"text\"</code> encoding, the flattened data that is persisted in SimpleDB will look like this:</p> <pre><code>{\n  \"Name\": \"example\",\n  \"Attributes\": [\n    { \"Name\": \"active\", \"Value\": \"true\" },\n    { \"Name\": \"props.image\", \"Value\": \"busybox\" },\n    { \"Name\": \"props.cpus\", \"Value\": \"2\" },\n    { \"Name\": \"props.memory\", \"Value\": \"2048\" },\n    { \"Name\": \"tags[]\", \"Value\": \"TAG_1\" },\n    { \"Name\": \"tags[]\", \"Value\": \"TAG_2\" }\n  ]\n}\n</code></pre>","title":"Example"},{"location":"getting-started/","text":"","title":"Getting started"},{"location":"getting-started/#installation","text":"<p>Isotopes can be installed with <code>npm</code>:</p> <pre><code>npm install isotopes aws-sdk\n</code></pre> <p>TypeScript typings are provided as part of the package, so no need to install a separate package. The aws-sdk is listed as a peer dependency, so make sure it is installed. Note that when you run Isotopes from within AWS Lambda the SDK is already installed.</p>","title":"Installation"},{"location":"getting-started/#usage","text":"<p>Isotopes = SimpleDB + TypeScript</p> <p>The following instructions are intended for usage with TypeScript. You can also use Isotopes from plain JavaScript by omitting all typings from the examples, but what would be the point? Learn TypeScript, it's awesome!</p>  <p>First, import Isotopes into your project:</p> <pre><code>import { Isotope } from \"isotopes\"\n</code></pre> <p>Next, define a TypeScript interface for the data you want to store, e.g. a type for running a task on a cluster:</p> <pre><code>export interface Task {\n  id: string                           /* Unique identifier */\n  active: boolean                      /* Whether the task can be scheduled */\n  props: {\n    image: string                      /* Docker image to use */\n    cpus: number                       /* Number of CPUs */\n    memory: number                     /* Reserved memory */\n    command?: string                   /* Command override */\n  },\n  tags: string[]                       /* Tags for categorization */\n}\n</code></pre> <p>Every type that is handled by Isotopes must contain a unique identifier which is used as an item name. The item name must be on the first level of the type to be stored, all other variables can be arbitrarily nested. Next, create an isotope for the type, e.g. for a SimpleDB domain named <code>tasks</code>:</p> <pre><code>const tasks = new Isotope&lt;Task&gt;({\n  domain: \"tasks\",                     /* SimpleDB domain name */\n  key: \"id\"                            /* SimpleDB item name (primary key) */\n})\n</code></pre> <p>Now, suppose we have the following item:</p> <pre><code>const task: Task = {\n  id: \"example\",\n  active: true,\n  props: {\n    image: \"busybox\",\n    cpus: 2,\n    memory: 2048\n  },\n  tags: [\n    \"TAG_1\",\n    \"TAG_2\"\n  ]\n}\n</code></pre> <p>We can persist, retrieve and delete items from the isotope by using a simple API, cleverly omitting all the boilerplate that is normally necessary for interfacing with SimpleDB.</p>","title":"Usage"},{"location":"getting-started/#create-a-domain","text":"<p>Reference for <code>Isotope.create</code></p>  <p>If the SimpleDB domain doesn't exist, create it:</p> <pre><code>await isotope.create()\n</code></pre>","title":"Create a domain"},{"location":"getting-started/#persist-an-item","text":"<p>Reference for <code>Isotope.put</code></p>  <p>Persisting an item is as simple as:</p> <pre><code>await tasks.put(task) // =&gt; void\n</code></pre>","title":"Persist an item"},{"location":"getting-started/#retrieve-an-item","text":"<p>Reference for <code>Isotope.get</code></p>  <p>Retrieving an item by primary key (unique identifier, in our example <code>id</code>):</p> <pre><code>const task = await tasks.get(\"example\") // =&gt; Task | undefined\n</code></pre>","title":"Retrieve an item"},{"location":"getting-started/#delete-an-item","text":"<p>Reference for <code>Isotope.delete</code></p>  <p>Delete an item by primary key:</p> <pre><code>await tasks.delete(\"example\") // =&gt; void\n</code></pre>","title":"Delete an item"},{"location":"getting-started/#query-a-domain","text":"<p>Reference for <code>Isotope.select</code></p>  <p>We can also build queries using a stripped-down version of the squel query builder interface:</p> <pre><code>const expr = tasks.getQueryBuilder()\n  .where(\"`active` = ? and `props.memory` &gt; ?\", true, 0)\n  .order(\"`props.memory`\", \"asc\")\n  .limit(100)\n</code></pre> <p>The query expression can then be used to perform a <code>SELECT</code> operation:</p> <pre><code>await tasks.select(expr)\n</code></pre>","title":"Query a domain"},{"location":"getting-started/#handling-errors","text":"<p>All methods except <code>getQueryBuilder</code> return Promises, so they are best to be used with ES7's <code>async/await</code> and wrapped in <code>try/catch</code> blocks for error handling purposes:</p> <pre><code>try {\n  await tasks.put(task)\n} catch (err) {\n  /* Handle error */\n}\n</code></pre>","title":"Handling errors"},{"location":"license/","text":"<p>MIT License</p> <p>Copyright \u00a9 2018-2020 Martin Donath</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>","title":"License"},{"location":"release-notes/","text":"","title":"Release notes"},{"location":"release-notes/#upgrading","text":"<p>To upgrade Isotopes to the latest version, use <code>npm</code>:</p> <pre><code>npm update isotopes\n</code></pre>","title":"Upgrading"},{"location":"release-notes/#changelog","text":"","title":"Changelog"},{"location":"release-notes/#061-_-july-11-2020","text":"<ul> <li>Updated dependencies to fix security vulnerabilities</li> </ul>","title":"0.6.1 _ July 11, 2020"},{"location":"release-notes/#060-_-april-13-2020","text":"<ul> <li>Added support for passing options directly to SimpleDB</li> </ul>","title":"0.6.0 _ April 13, 2020"},{"location":"release-notes/#051-_-december-26-2018","text":"<ul> <li>Updated dependencies to fix security vulnerabilities</li> </ul>","title":"0.5.1 _ December 26, 2018"},{"location":"release-notes/#050-_-august-7-2018","text":"<ul> <li>Removed retryability implementation (AWS SDK provides it)</li> </ul>","title":"0.5.0 _ August 7, 2018"},{"location":"release-notes/#042-_-august-7-2018","text":"<ul> <li>Fixed failing delete operation without attribute names</li> </ul>","title":"0.4.2 _ August 7, 2018"},{"location":"release-notes/#041-_-august-7-2018","text":"<ul> <li>Added missing typings to dependencies</li> </ul>","title":"0.4.1 _ August 7, 2018"},{"location":"release-notes/#040-_-august-5-2018","text":"<ul> <li>Added fault-tolerance (retryability) to all SimpleDB client requests</li> </ul>","title":"0.4.0 _ August 5, 2018"},{"location":"release-notes/#032-_-august-2-2018","text":"<ul> <li>Added runtime check to <code>Isotope.put</code> for presence of item name</li> <li>Added comments to TypeScript annotations</li> <li>Fixed generic partial types to be too shallow</li> </ul>","title":"0.3.2 _ August 2, 2018"},{"location":"release-notes/#032-_-august-1-2018","text":"<ul> <li>Added utility types for recursively making types all optional or required</li> </ul>","title":"0.3.2 _ August 1, 2018"},{"location":"release-notes/#031-_-july-30-2018","text":"<ul> <li>Fixed handling of undefined values in <code>WHERE</code> clauses</li> </ul>","title":"0.3.1 _ July 30, 2018"},{"location":"release-notes/#030-_-july-30-2018","text":"<ul> <li>Added support for domain creation and destruction</li> <li>Refactored result to return token value instead of function</li> </ul>","title":"0.3.0 _ July 30, 2018"},{"location":"release-notes/#020-_-july-29-2018","text":"<ul> <li>Added support for multi-attribute values</li> </ul>","title":"0.2.0 _ July 29, 2018"},{"location":"release-notes/#011-_-july-27-2018","text":"<ul> <li>Fixed entrypoint and typings</li> </ul>","title":"0.1.1 _ July 27, 2018"},{"location":"release-notes/#010-_-july-27-2018","text":"<ul> <li>Initial release</li> </ul>","title":"0.1.0 _ July 27, 2018"},{"location":"reference/isotope/create/","text":"<p>Create the SimpleDB domain</p>","title":"Isotope.create"},{"location":"reference/isotope/create/#signature","text":"<pre><code>Isotope&lt;T, TPut = T, TGet = T&gt;.create(): Promise&lt;void&gt;\n</code></pre> <p>Isotopes provides a thin wrapper around AWS SimpleDB domains which enables storage and retrieval of typed hierarchical data, but it won't create or destroy domains automatically. While this method will create a SimpleDB domain, it is absolutely recommended to use Terraform for creation and destruction.</p>","title":"Signature"},{"location":"reference/isotope/create/#parameters","text":"<p>none</p>","title":"Parameters"},{"location":"reference/isotope/create/#example","text":"<pre><code>await isotope.create()\n</code></pre>","title":"Example"},{"location":"reference/isotope/delete/","text":"<p>Delete an item from SimpleDB</p>","title":"Isotope.delete"},{"location":"reference/isotope/delete/#signature","text":"<pre><code>Isotope&lt;T, TPut = T, TGet = T&gt;.delete(\n  id: string,\n  names?: string[]\n): Promise&lt;void&gt;\n</code></pre> <p>This operation is idempotent, which means that executing the same operation twice will always yield the same result.</p>","title":"Signature"},{"location":"reference/isotope/delete/#parameters","text":"<code>id</code>  <p>Identifier \u2014 unique value used for identification (SimpleDB item name).</p>  <code>names</code>  <p>Attribute names \u2014 optional \u2014 a set of flattened field names that should be deleted from SimpleDB. By providing attribute names, specific fields can be deleted keeping the item alive. If this parameter is omitted, the whole item is deleted.</p>","title":"Parameters"},{"location":"reference/isotope/delete/#example","text":"<pre><code>await isotope.delete(id)\n</code></pre>","title":"Example"},{"location":"reference/isotope/destroy/","text":"<p>Destroy the SimpleDB domain</p>","title":"Isotope.destroy"},{"location":"reference/isotope/destroy/#signature","text":"<pre><code>Isotope&lt;T, TPut = T, TGet = T&gt;.destroy(): Promise&lt;void&gt;\n</code></pre> <p>Isotopes provides a thin wrapper around AWS SimpleDB domains which enables storage and retrieval of typed hierarchical data, but it won't create or destroy domains automatically. While this method will create a SimpleDB domain, it is absolutely recommended to use Terraform for creation and destruction.</p>","title":"Signature"},{"location":"reference/isotope/destroy/#parameters","text":"<p>none</p>","title":"Parameters"},{"location":"reference/isotope/destroy/#example","text":"<pre><code>await isotope.destroy()\n</code></pre>","title":"Example"},{"location":"reference/isotope/get-query-builder/","text":"<p>Create an SQL query expression builder</p>","title":"Isotope.getQueryBuilder"},{"location":"reference/isotope/get-query-builder/#signature","text":"<pre><code>Isotope&lt;T, TPut = T, TGet = T&gt;.getQueryBuilder(): IsotopeSelect\n</code></pre> <p>This method returns an object of type <code>IsotopeSelect</code>.</p>","title":"Signature"},{"location":"reference/isotope/get-query-builder/#parameters","text":"<p>none</p>","title":"Parameters"},{"location":"reference/isotope/get-query-builder/#example","text":"<pre><code>const expr = isotope.getQueryBuilder()\n</code></pre>","title":"Example"},{"location":"reference/isotope/get/","text":"<p>Retrieve an item from SimpleDB</p>","title":"Isotope.get"},{"location":"reference/isotope/get/#signature","text":"<pre><code>Isotope&lt;T, TPut = T, TGet = T&gt;.get(\n  id: string,\n  names?: string[]\n): Promise&lt;TGet | DeepPartial&lt;TGet&gt; | undefined&gt;\n</code></pre> <p>Note that this method may return partial items if they are stored as such in SimpleDB, so to obtain type safety with TypeScript, you have to make sure that all items define all required fields before retrieving them from SimpleDB. If unsure, it's best to configure Isotopes with <code>Partial&lt;T&gt;</code> or <code>DeepPartial&lt;T&gt;</code> for <code>TGet</code>, see this section.</p>","title":"Signature"},{"location":"reference/isotope/get/#parameters","text":"<code>id</code>  <p>Identifier \u2014 unique value used for identification (SimpleDB item name).</p>  <code>names</code>  <p>Attribute names \u2014 optional \u2014 a set of flattened field names that should be retrieved from SimpleDB. If this parameter is omitted SimpleDB will return all attributes for a given item. If this parameter is specified, the Promise will resolve with a <code>DeepPartial&lt;TGet&gt;</code> type.</p>","title":"Parameters"},{"location":"reference/isotope/get/#example","text":"<pre><code>const item = await isotope.get(id)\n</code></pre>","title":"Example"},{"location":"reference/isotope/new/","text":"<p>Create a SimpleDB domain client</p>","title":"Isotope"},{"location":"reference/isotope/new/#signature","text":"<pre><code>new Isotope&lt;T, [TPut, [TGet]]&gt;(\n  options: IsotopeOptions&lt;T&gt;\n): Isotope&lt;T&gt;\n</code></pre> <p>Initializes an isotope using the given options of which <code>domain</code> and <code>key</code> are mandatory. The <code>format</code> option can be used to define the serialization method that is used for the values before writing them to SimpleDB. The <code>client</code> option enables configuration of the SimpleDB client.</p>","title":"Signature"},{"location":"reference/isotope/new/#typings","text":"<p>By default, Isotopes forces only valid entries to be written to SimpleDB which means that all non-optional fields need to be defined in the payload (otherwise the TypeScript compiler will moan). However, SimpleDB allows reading and writing of partial attribute values, so it might be desirable in some cases to loosen that restriction and allow partial reads and writes. Isotopes allows both configurations through simple generic typing.</p> <pre><code>class Isotope&lt;\n  T    extends {},                     /* Data type */\n  TPut extends DeepPartial&lt;T&gt; = T,     /* Data type expected by PUT operation */\n  TGet extends DeepPartial&lt;T&gt; = TPut   /* Data type returned by GET operation */\n&gt; {}\n</code></pre> <p>The first type argument is mandatory and defines the base type. The second and third type arguments can be used to specify what exact types <code>PUT</code> and <code>GET</code> operations return but normally they are equal to the base type.</p> <ul> <li> <p>Allow complete values only:</p> <pre><code>new Isotope&lt;T&gt;(...)\n</code></pre> </li> <li> <p>Allow partial values in <code>PUT</code> and <code>GET</code> operations:</p> <pre><code>new Isotope&lt;T, DeepPartial&lt;T&gt;&gt;(...)\n</code></pre> </li> <li> <p>Allow partial values in <code>GET</code> operations only:</p> <pre><code>new Isotope&lt;T, T, DeepPartial&lt;T&gt;&gt;(...)\n</code></pre> </li> </ul> <p>The <code>DeepPartial</code> type is exported by Isotopes.</p>","title":"Typings"},{"location":"reference/isotope/new/#parameters","text":"<code>options.domain</code>  <p>SimpleDB domain name</p>  <code>options.key</code>  <p>SimpleDB item name (primary key)</p>  <code>options.format.encoding</code>  <p>Encoding method for values \u2014 optional, default: <code>\"json\"</code> \u2014 please see this section to learn how the available encoding methods <code>\"json\"</code> and <code>\"text\"</code> determine how values are written to SimpleDB.</p>  <code>options.format.multiple</code>  <p>Write multi-attribute values for arrays \u2014 optional, default: <code>true</code> \u2014 please see this section to learn how this will impact object flattening and persistence within SimpleDB.</p>  <code>options.client.consistent</code>  <p>Use consistent reads for <code>GET</code> and <code>SELECT</code> operations \u2014 optional, default: <code>false</code> \u2014 see the official documentation for further information on consistency within SimpleDB.</p>","title":"Parameters"},{"location":"reference/isotope/new/#example","text":"<pre><code>const isotope = new Isotope&lt;T&gt;({\n  domain: \"&lt;domain&gt;\",\n  key: \"&lt;keyof T&gt;\",\n\n  /* Optional: format options */\n  format: {\n    encoding: \"json\",\n    multiple: true\n  },\n\n  /* Optional: SimpleDB client options */\n  client: {\n    consistent: false\n  }\n})\n</code></pre>","title":"Example"},{"location":"reference/isotope/put/","text":"<p>Persist an item within SimpleDB</p>","title":"Isotope.put"},{"location":"reference/isotope/put/#signature","text":"<pre><code>Isotope&lt;T, TPut = T, TGet = T&gt;.put(data: TPut): Promise&lt;void&gt;\n</code></pre>","title":"Signature"},{"location":"reference/isotope/put/#parameters","text":"<code>data</code>  <p>Data to be persisted \u2014 by default, partial data will trigger TypeScript errors due to the specified typings. In order to write partial data, Isotopes must be configured with <code>Partial&lt;T&gt;</code> or <code>DeepPartial&lt;T&gt;</code> for <code>TPut</code>, see this section.</p> <p>Before delegating to SimpleDB, the keys of the data object are flattened and the values are encoded according to the method specified in <code>options.format.encoding</code> during initialization of the isotope.</p>","title":"Parameters"},{"location":"reference/isotope/put/#example","text":"<pre><code>await isotope.put(data)\n</code></pre>","title":"Example"},{"location":"reference/isotope/select/","text":"<p>Retrieve a set of items from SimpleDB matching a given SQL query expression</p>","title":"Isotope.select"},{"location":"reference/isotope/select/#signature","text":"<pre><code>Isotope&lt;T, TPut = T, TGet = T&gt;.select&lt;TSelect extends TGet = TGet&gt;(\n  expr: IsotopeSelect&lt;T&gt; | string,\n  prev?: string\n): Promise&lt;IsotopeResult&lt;TSelect&gt;&gt;\n</code></pre> <p>By default, <code>SELECT</code> operations are assumed to return the same type as <code>GET</code>. As this may differ by usecase (depending on the specific SQL query), it may be overridden on a per-query basis.</p>","title":"Signature"},{"location":"reference/isotope/select/#parameters","text":"<code>expr</code>  <p>Query builder or string containing a SQL query expression \u2014 the easiest way to construct SQL queries that can be understood by SimpleDB is using the query builder which is implemented using squel. A query builder can be obtained using <code>getQueryBuilder()</code>.</p>  <code>prev</code>  <p>Pagination token, optional \u2014 a <code>SELECT</code> operation returns a pagination token if there are more results to fetch, as SimpleDB uses token-based pagination. This token can then be passed to the same method using the same SQL query expression to obtain the next page of items.</p>","title":"Parameters"},{"location":"reference/isotope/select/#example","text":"<pre><code>let prev\ndo {\n  const { items, next } = await isotope.select(expr, prev)\n  items.map(console.log)\n  prev = next\n} while (prev)\n</code></pre>","title":"Example"},{"location":"reference/isotope-select/limit/","text":"<p>Add an LIMIT clause to a SQL query expression</p>","title":"IsotopeSelect.limit"},{"location":"reference/isotope-select/limit/#signature","text":"<pre><code>IsotopeSelect&lt;T&gt;.limit(\n  count: number\n): this\n</code></pre>","title":"Signature"},{"location":"reference/isotope-select/limit/#parameters","text":"<code>count</code>  <p>Number of records.</p>","title":"Parameters"},{"location":"reference/isotope-select/limit/#example","text":"<pre><code>// SELECT * FROM `domain` LIMIT 100\nisotope.getQueryBuilder()\n  .limit(100)\n  .toString()\n</code></pre>","title":"Example"},{"location":"reference/isotope-select/new/","text":"<p>Create a SQL query expression builder</p>","title":"IsotopeSelect"},{"location":"reference/isotope-select/new/#signature","text":"<pre><code>new IsotopeSelect&lt;T]&gt;(\n  options: IsotopeOptions&lt;T&gt;,\n): Isotope&lt;T&gt;\n</code></pre> <p>The query builder should not be instantiated manually. It's better to use <code>Isotope.getQueryBuilder</code> because the isotope will pass its options to the constructor.</p>","title":"Signature"},{"location":"reference/isotope-select/new/#parameters","text":"<code>options</code>  <p>Same as the options passed to the isotope constructor, see here.</p>","title":"Parameters"},{"location":"reference/isotope-select/new/#example","text":"<pre><code>const expr = isotope.getQueryBuilder()\n</code></pre>","title":"Example"},{"location":"reference/isotope-select/order/","text":"<p>Add an ORDER BY clause to a SQL query expression</p>","title":"IsotopeSelect.order"},{"location":"reference/isotope-select/order/#signature","text":"<pre><code>IsotopeSelect&lt;T&gt;.order(\n  field: string,\n  direction?: \"asc\" | \"desc\"\n): this\n</code></pre>","title":"Signature"},{"location":"reference/isotope-select/order/#parameters","text":"<code>field</code>  <p>Sort field.</p>  <code>direction</code>  <p>Sort direction \u2014 optional, default: <code>\"asc\"</code>.</p>","title":"Parameters"},{"location":"reference/isotope-select/order/#example","text":"<pre><code>// SELECT * FROM `domain` ORDER BY `key` ASC\nisotope.getQueryBuilder()\n  .order(\"`key`\")\n  .toString()\n</code></pre>","title":"Example"},{"location":"reference/isotope-select/where/","text":"<p>Add a WHERE clause to a SQL query expression</p>","title":"IsotopeSelect.where"},{"location":"reference/isotope-select/where/#signature","text":"<pre><code>IsotopeSelect&lt;T&gt;.where(\n  condition: string,\n  ...args: any[]\n): this\n</code></pre>","title":"Signature"},{"location":"reference/isotope-select/where/#parameters","text":"<code>condition</code>  <p>Condition expression \u2014 an expression can contain various placeholders, namely <code>?</code> which can be passed as variadic arguments. See the official AWS documentation on the SimpleDB query language in order to learn about the types of expressions that can be used in SQL queries or see this section for some usage examples. A brief overview:</p> <ul> <li>Comparison operators</li> <li>Simple queries</li> <li>Range queries</li> <li>Queries on attributes with multiple values</li> <li>Multiple attribute queries</li> </ul>  <code>...args</code>  <p>Placeholder arguments which are replaced in the condition expression \u2014 note that string values are auto-quoted if the encoding is set to <code>\"json\"</code>. If the condition contains a <code>LIKE</code> expression, string values must include a <code>%</code> sign which is not quoted, so JSON values can also be searched.</p>","title":"Parameters"},{"location":"reference/isotope-select/where/#example","text":"","title":"Example"},{"location":"reference/isotope-select/where/#_1","text":"<p><code>`` ts tab=\"JSON encoding\" // SELECT * FROM</code>domain<code>WHERE (</code>key<code>= '\"value\"') isotope.getQueryBuilder()   .where(\"</code>key` = ?\", \"value\")   .toString() <pre><code>``` ts tab=\"Text encoding\"\n// SELECT * FROM `domain` WHERE (`key` = 'value')\nisotope.getQueryBuilder()\n  .where(\"`key` = ?\", \"value\")\n  .toString()\n</code></pre></p>","title":"<code>=</code>"},{"location":"reference/isotope-select/where/#like","text":"<p><code>`` ts tab=\"JSON encoding\" // SELECT * FROM</code>domain<code>WHERE (</code>key<code>LIKE '\"value%') isotope.getQueryBuilder()   .where(\"</code>key` LIKE ?\", \"value%\")   .toString() <pre><code>``` ts tab=\"Text encoding\"\n// SELECT * FROM `domain` WHERE (`key` LIKE 'value%')\nisotope.getQueryBuilder()\n  .where(\"`key` LIKE ?\", \"value%\")\n  .toString()\n</code></pre></p>","title":"<code>LIKE</code>"},{"location":"reference/isotope-select/where/#and","text":"<p><code>`` ts tab=\"JSON encoding\" // SELECT * FROM</code>domain<code>WHERE (</code>key<code>&gt;= '1') AND (</code>key<code>&lt;= '2') isotope.getQueryBuilder()   .where(\"</code>key<code>&gt;= ?\", 1)   .where(\"</code>key` &lt;= ?\", 2)   .toString() <pre><code>``` ts tab=\"Text encoding\"\n// SELECT * FROM `domain` WHERE (`key` &gt;= '1') AND (`key` &lt;= '2')\nisotope.getQueryBuilder()\n  .where(\"`key` &gt;= ?\", 1)\n  .where(\"`key` &lt;= ?\", 2)\n  .toString()\n</code></pre></p>","title":"<code>AND</code>"},{"location":"reference/isotope-select/where/#or","text":"<p><code>`` ts tab=\"JSON encoding\" // SELECT * FROM</code>domain<code>WHERE (</code>key<code>= '1' OR</code>key<code>= '2') isotope.getQueryBuilder()   .where(\"</code>key<code>= ? OR</code>key` = ?\", 1, 2)   .toString() <pre><code>``` ts tab=\"Text encoding\"\n// SELECT * FROM `domain` WHERE (`key` = '1' OR `key` = '2')\nisotope.getQueryBuilder()\n  .where(\"`key` = ? OR `key` = ?\", 1, 2)\n  .toString()\n</code></pre></p>","title":"<code>OR</code>"}]}